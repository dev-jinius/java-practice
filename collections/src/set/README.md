# 해시 알고리즘 V0
## hashIndex
- 해시 인덱스: 데이터를 배열의 크기로 나머지 연산을 해서 구한 값(인덱스).
- 배열의 크기가 10이고, 데이터가 14라면, 14 / 10 = 1...4 이므로 해시 인덱스는 4이다.
- 해시 인덱스를 저장할 배열의 인덱스로 사용해서 데이터를 저장한다.

## 해시 충돌
- 다른 입력 값이지만 같은 해시 코드가 나오는 경우
- 해결: 여러 값을 저장할 수 있는 자료구조로 해당 인덱스에 저장한다.
  - 배열 안에 배열
  - 배열 안에 리스트
- 해시 인덱스를 저장할 배열의 크기: 통계적으로 데이터 수가 배열의 크기의 75% 이하로 설정.
  - 배열의 크기가 너무 작으면 해시 충돌이 많아져 성능이 나빠진다.
  - 배열이 크기가 너무 크면 성능은 좋아지지만, 메모리 낭비가 심해진다.
  - 데이터 수가 배열의 75% 정도 되도록 기준을 잡는 것이 좋다.

## 해시 인덱스 시간복잡도
### 데이터 저장
- 평균: O(1)
- 최악: O(N) - 해시 충돌이 일어나 중복데이터를 체크하기 위해
### 데이터 조회
- 평균: O(1)
- 최악: O(N)

# 해시 알고리즘 V1
## 해시 함수(Hash Function)
- 해시 함수는 임의의 길이의 데이터를 입력 받아, 고정된 길이의 해시값(해시 코드)를 출력하는 함수이다.
- 같은 데이터를 입력하면 항상 같은 해시 코드가 출력된다.
- 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. (해시 충돌)
  - 66+67 = 133, 65+68 = 133

## 해시 코드(Hash Code)
- 데이터를 대표하는 값으로 보통 해시 함수를 통해 만들어진다.
- A -> 65, B -> 66, AB -> 133

## 해시 인덱스(Hash Index)
- 해시 인덱스는 데이터의 저장 위치를 결정하는데 주로 해시 코드를 사용해서 만든다.
- hashIndex = hashCode / 배열 size

# 해시 알고리즘 V2
## 자바의 hashCode() 메서드
- 숫자, 문자 뿐만 아니라 Java에는 객체가 존재하는데 User 같은 객체는 어떻게 해시코드를 정의할 수 있나?
- 자바는 모든 객체가 자신만의 해시 코드를 표현할 수 있는 기능을 제공한다. => Object에 있는 hashCode() 메서드!
- 마이너스 값이 나올 수 있다.

### Object의 hashCode()
![image](https://github.com/user-attachments/assets/c65d9e7f-2ea8-4ce1-8a4c-95d663bf0d26)
  - Object의 hashCode() 메서드는 보통 오버라이딩해서 사용한다.
  - Object의 hashCode()의 기본 구현은 객체의 참조값을 기반으로 해시 코드를 생성하기 때문에 객체의 인스턴스가 다르면 해시코드도 다르다.

### Objact와 동일성, 동등성
- Object는 동등성 비교를 위한 equals() 메서드를 제공한다.
- 자바에서 객체가 같다를 2가지로 표현할 수 있다.
  1. 동일성(Identity): `==` 연산자를 통해 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인한다.
  2. 동등성(Equality): `equals()` 메서드를 통해 두 객체가 논리적으로 동등한지 확인한다.
- 동일성은 물리적으로 같은 객체인지 확인하는 것이고, 동등성은 논리적으로 같은지 확인하는 것.
  ```java
  //물리적으로 다른 메모리에 있는 객체
  //논리적으로 `id1`로 같은 id를 갖고 있는 a, b는 같은 회원. => equals(), hashCode()를 재정의해야 한다.
  User a = new User("id1");
  User b = new User("id1");
  ```  

### equals()
- 해시 자료 구조를 사용할 때 hashCode()와 equals()도 필수로 재정의 해야 한다.
- 입력한 데이터가 기존에 있는지 비교할 때 equals()를 사용하기 때문에 재정의한 equals()로 비교해야 정확하다.
- 만약 equals()를 재정의하지 않고 사용하면, Object의 equals()를 사용하기 때문에 객체의 참조 값이 같은 것이 true이다. (메모리 상에 같은 객체여야 함.)

# MyHashSetV0
- 해시 인덱스를 사용하지 않고 배열만 사용.
- add() 로 데이터 추가 시 중복 데이터를 확인하기 위해 전체 데이터를 항상 확인한다. `O(N)`
- 데이터를 저장 `O(1)`

# MyHashSetV1
- 해시 인덱스를 사용하여 배열을 사용.
- buckets: 연결 리스트를 배열로 사용한다.
- buckets를 연결 리스트로 배열로 만든 이유는 해시 인덱스 충돌 시 여러 데이터를 저장하기 위함이다.

# MyHashSetV2
- hashIndex()
  - Object의 hashCode()를 재정의해서 해시 코드를 반환한다. 
  - 반환된 해시 코드를 배열의 크기(CAPACITY)로 나머지 연산해서 해시 인덱스를 구한다.
  - Math.abs()를 사용해 항상 양수로 반환한다.

# hashCode()와 equals() 오버라이딩 
- 해시 자료 구조를 사용하는 경우 반드시 hashCode()와 equals()를 재정의해서 사용해야 한다.
